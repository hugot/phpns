#!/bin/bash
##
# phpns - Resolve namespaces and fix missing use statements in your PHP scripts.

# shellcheck disable=SC2155
declare SCRIPT_DIR="$(cd "$(dirname "$(readlink "${BASH_SOURCE[0]}" || echo "${BASH_SOURCE[0]}")")" && pwd)"
declare CACHE_DIR=./.cache/phpns
declare INFO=1

[[ $DEBUG -eq 2 ]] && set -x
shopt -s extglob
shopt -so pipefail

#shellcheck disable=SC1090
include() {
    source "$SCRIPT_DIR"/../lib/"${1}".bash
}

include handle_arguments
include messaging
include find_uses_and_needs

read -rd '' USAGE <<'EOF'
    phpns - Resolve namespaces and fix missing use statements in your PHP scripts.
    
    USAGE:
        phpns COMMAND [ ARGUMENTS ] [ OPTIONS ]
    
    COMMANDS:
        ns, namespace FILE : resolve the namespace of a file.
        i, index : Index all php files in a project directory for usage.
        fu, find-use CLASS_NAME : Find the use statement needed to import the provided class.
        fxu, fix-uses FILE : Find all used classes that have no use statement in the provided file and add use statements for them.
        cns, classes-in-namespace NAMESPACE: List all classes for a certain namespace
        cmp, complete WORD: Complete FQN's for namespaces and classes that match WORD.

    TO BE IMPLEMENTED:
        rmuu, remove-unneeded-uses FILE: Remove all use statements for classes that are not being used.

    OPTIONS FOR ALL COMMANDS:
        -s --silent: Don't print info.
    
    UNIQUE OPTIONS PER COMMAND:
        namespace: -
        index: -
        find-use:
            -j, --json: Provide possible use FQN's as a json array.
            -p, --prefer-own: If there are matches inside the "src" dir, only use those.
            -a, --auto-pick: Use first encountered match, don't provide a choice.
            -b. --bare: Print FQN's without any additives.
        fix-uses:
            -j, --json: Provide possible use FQN's per class as a json object with the class names as keys.
            -p, --prefer-own: If there are matches inside the "src" dir, only use those.
            -a, --auto-pick: Use first encountered match, for every class, don't provide a choice.
            -o, --stdout: Print to stdout in stead of printing to the selected file.
        complete:
            -e, --expand-classes: If word is a class name and no namespaces match, provide the FQN for the class that matches WORD.
            -n, --no-classes: Only complete FQN's for namespaces.

EOF

execute() {
    declare command="$1" INFO="$INFO"
    declare -a CONFIG=()
    shift

    if [[ $command == @(-h|--help|help) ]]; then
        echo "$USAGE" >&2
        exit 0
    fi

    if ! [[ -f ./composer.json ]] && ! [[ -d ./.git ]]; then
        echo "No composer.json or .git file found, not in root of poject, exiting." >&2
        exit 1
    fi

    case "$command" in
        ns | namespace)
            checkCache
            declare file="$1" cached_file="$CACHE_DIR/$1"

            if [[ -f "$cached_file" ]]; then
                grep 'namespace' "$cached_file" | sed 's/namespace\s*//; s/;$//;'
            elif [[ -f "$file" ]]; then
                grep 'namespace' "$file" | sed 's/namespace\s*//; s/;$//;'
            fi
            ;;
        i | index)
            handleArguments index "$@" || return $?
            [[ -d $CACHE_DIR ]] || mkdir -p "$CACHE_DIR"
            rm -rf "${CACHE_DIR:?}"/*
            grep -r '^\(class\|abstract class\|namespace\|interface\|trait\) [A-Za-z]\+' -m 2 --exclude-dir={.cache,var} --include='*.php' | fillUseIndex
            ;;
        fu | find-use)
            checkCache
            handleArguments find-use "$@" || return $?
            declare use_path='' class_name="${CONFIG[$CLASS_NAME]}"
            if [[ "$class_name" == @(array|string|float|int|void|mixed) ]]; then
                infof 'Type "%s" is not a class, but a primitive type.\n' "$class_name"
                return 1
            fi

            findUsePathForClass "$class_name"
            ;;
        fxu | fix-uses)
            checkCache
            handleArguments fix-uses "$@" || return $?
            declare file="$1"
            if [[ ${CONFIG[$STDOUT]} == '--stdout' ]]; then
                fixMissingUseStatements "$file"
            else
                # shellcheck disable=SC2005
                echo "$(fixMissingUseStatements "$file")" > "$file"
            fi
            ;;
        cns | classes-in-namespace)
            handleArguments classes-in-namespace "$@" || return $?
            checkCache
            debug "Checking for namespace ${CONFIG[$NAMESPACE]}"
            declare namespace="${CONFIG[$NAMESPACE]}"
            # shellcheck disable=SC2155
            declare matching_files="$(grep -r 'namespace[[:blank:]]\+'"${namespace//\\/\\\\}"'[[:blank:]]*;' --files-with-matches -m 1 "$CACHE_DIR")"
            debug "Matching files: $matching_files"
            declare dir="${matching_files%%/+([^/]).php*}"
            debug "Searching dir: $dir"
            [[ -z $dir ]] && return 1
            grep -hPod skip '(?<=class|abstract class|interface|trait)[[:blank:]]+[A-Za-z]+' "$dir"/* \
                | sed 's/^[[:blank:]]\+//g'
            ;;
        cmp | complete)
            handleArguments complete "$@" || return $?
            checkCache
            declare match='false' word="${CONFIG[$WORD]}"
            if grep -rhPom 1 '(?<=namespace)[[:blank:]]+'"${word//\\/\\\\}"'[A-Za-z]*' "$CACHE_DIR" \
                | sort -u; then
                match='true'
            fi

            if ! [[ ${CONFIG[$NO_CLASSES]} == '--no-classes' ]]; then
                declare cur_namespace="${word%\\*([^\\])}" 
                debugf 'checking namespace "%s"' "$cur_namespace"
                if compgen -P "$cur_namespace\\" -W "$(execute cns "$cur_namespace")" "${word##*\\}"; then
                    match='true'
                fi
            fi

            if ! $match && [[ ${CONFIG[$EXPAND_CLASSES]} == '--expand-classes' ]] && [[ $word == +([A-Za-z]) ]]; then
                declare -a possibilities=()
                possibilities=($(execute fu --prefer-own --silent --bare "$word"))
                if [[ ${#possibilities[@]} -gt 1 ]]; then
                    echo "$word"
                fi
                printf '%s\n' "${possibilities[@]}"

            fi
            ;;
        fp | filepath)
            handleArguments filepath "$@" || return $?
            checkCache
            declare full_use_path="${CONFIG[$CLASS_PATH]}"
            declare namespace="${full_use_path%\\*}"
            declare class="${full_use_path##*\\}"
            debugf 'namespace: "%s" class: "%s"\n' "$namespace" "$class"
            (cd "$CACHE_DIR" && grep -rPzl "${namespace//\\/\\\\}"';\n(class|abstract class|interface) '"$class"'(\s+|$)' src/)
            ;;
        *)
            printf 'Command "%s" is not a valid phpns command.\n' "$command" >&2
            exit 1
            ;;
    esac
}

# shellcheck disable=SC2034
fixMissingUseStatements() {
    declare check_uses='false' check_needs='false' file="$1"
    declare -A uses=() needs=() namespace=()
    declare -a classes=()
    
    classes=($(execute cns "$(execute ns "$file")"))
    for class in "${classes[@]}"; do
        namespace["$class"]='in_namespace'
    done

    findUsesAndNeeds < "$file"
    addUseStatements "${!needs[@]}" < "$file"
}

findUsePathForClass() {
    declare class="$1"
    if [[ ${CONFIG[$PREFER_OWN]} == '--prefer-own' ]]; then
        declare -a files=($(grep -rl '\(class\|abstract class\|interface\|trait\)'"\\s\\+${CONFIG[$CLASS_NAME]}\(\\s\\+\|$\)" "$CACHE_DIR/src"))
    else
        declare -a files=($(grep -rl '\(class\|abstract class\|interface\|trait\)'"\\s\\+${CONFIG[$CLASS_NAME]}\(\\s\\+\|$\)" "$CACHE_DIR"))
    fi
    declare -a presentable_files=($(for f in "${files[@]}"; do echo "${f#$CACHE_DIR/}"; done))

    if [[ ${#presentable_files[@]} -eq 1 ]]; then
        use_path="$(getUsePath "${presentable_files[0]}" "$class_name")"
    elif [[ ${#presentable_files[@]} -eq 0 ]]; then
        _handle_no_use || return $?
    else
        _handle_multiple_uses
    fi

    infof 'Found use statement for "%s"\n' "$use_path" >&2
    if [[ ${CONFIG[$JSON]} == '--json' ]]; then
        echo '['
        echo "$use_path"
        printf ']'
    elif [[ ${CONFIG[$BARE]} ]]; then
        echo "$use_path"
    else
        echo "use $use_path;"
    fi
}

_handle_no_use() {
    if [[ ${CONFIG[$PREFER_OWN]} == '--prefer-own' ]]; then
        CONFIG[$PREFER_OWN]=
        execute fu "${CONFIG[@]}"
        return $?
    else
        infof 'No match found for class "%s"\n' "$class_name" >&2
        [[ ${CONFIG[$JSON]} == '--json' ]] && printf '[]'
    fi
    return 1
}

_handle_multiple_uses() {
    if [[ ${CONFIG[$AUTO_PICK]} == '--auto-pick' ]]; then
        use_path="$(getUsePath "${files[0]}" "$class_name")"

        return 0
    elif [[ ${CONFIG[$BARE]} == '--bare' ]]; then
        use_path="$(
        for i in "${!files[@]}"; do
            getUsePath "${files[$i]}" "$class_name"
        done 
        )"

        return 0
    elif [[ ${CONFIG[$JSON]} == '--json' ]]; then
        use_path="$(
        for i in "${!files[@]}"; do
            getUsePath "${files[$i]}" "$class_name"
            echo -n "$use_path"
            [[ $i -lt $((${#files[@]}-1)) ]] && printf ','
            echo
        done 
        )"
        
        return 0
    fi

    for i in "${!presentable_files[@]}"; do
        presentable_files[$i]="${presentable_files[$i]} - $(execute ns "${presentable_files[$i]}")\\$class_name"
    done

    infof 'Multiple matches for class "%s", please pick one file.\n' "$class_name" >&2
    select file in "${presentable_files[@]}"; do
        use_path="${file##*- }"
        break
    done < /dev/tty
}

fillUseIndex() {
    declare -A files=()
    while IFS=':' read -ra line; do
        declare file="$CACHE_DIR/${line[0]}"
        declare dir="${file%/*}"

        [[ -d "$dir" ]] || mkdir -p "$dir"
        echo "${line[1]}" >> "$file"
        files["${line[0]}"]='indexed'
        if [[ $((${#files[@]}%500)) == 0 ]]; then
            info "indexed ${#files[@]} files."
        fi
    done
    
    info "Finished indexing. Indexed ${#files[@]} files." >&2
}

addUseStatements() {
    declare -a needs=("$@")
    declare use_statements=''
    if [[ ${CONFIG[$JSON]} == '--json' ]]; then
        declare -i length="$((${#needs[@]}-1))" current=0
        echo '{'
        for needed in "${needs[@]}"; do
            printf '"%s": ' "$needed"
            execute fu --json "$needed" "${CONFIG[$PREFER_OWN]}" "${CONFIG[$AUTO_PICK]}"
            [[ $((current++)) -lt $length ]] && printf ','
            echo
        done
        echo '}'

        return 0
    fi

    while IFS='' read -r line; do
        echo "$line"

        if [[ $line == namespace* ]]; then
            IFS='' read -r line && echo "$line"

            use_statements="$(
            for needed in "${needs[@]}"; do
                execute fu "$needed" "${CONFIG[$PREFER_OWN]}" "${CONFIG[$AUTO_PICK]}"
            done | sort
            )"

            [[ -n $use_statements ]] && echo "$use_statements"
        fi
    done

    declare -i added_uses=0
    added_uses="$(echo -n "$use_statements" | wc -l)"
    [[ -n $use_statements ]] && ((added_uses++))
    info "$added_uses use statements added out of ${#needs[@]} needed types. Types that were needed:" >&2
    infof '           - "%s"\n' "${needs[@]}" >&2
}

# shellcheck disable=SC2155
getUsePath() {
    declare file="$1" class_name="$2"
    declare use_path="$(execute ns "$file")\\$class_name"
    if [[ ${CONFIG[$JSON]} == '--json' ]]; then
        printf '"%s"' "${use_path//\\/\\\\}"
    else
        echo "$use_path"
    fi
}

checkCache() {
    if ! [[ -d "$CACHE_DIR" ]]; then
        info "No cache dir found, indexing." >&2
        execute index
    fi
}

execute "$@"
