#!/bin/bash
##
# phpns - Resolve namespaces and fix missing use statements in your PHP scripts.

# shellcheck disable=SC2155
declare SCRIPT_DIR="$(cd "$(dirname "$(readlink "${BASH_SOURCE[0]}" || echo "${BASH_SOURCE[0]}")")" && pwd)"
declare CACHE_DIR=./.cache/phpns
declare TREE_DIR="$CACHE_DIR/tree"
declare CLASSES="$CACHE_DIR/classes"
declare NAMESPACES="$CACHE_DIR/namespaces"
declare INFO=1

[[ $DEBUG -eq 2 ]] && set -x
shopt -s extglob
shopt -so pipefail

#shellcheck disable=SC1090
include() {
    source "$SCRIPT_DIR"/../lib/"${1}".bash
}

include handle_arguments
include messaging
include find_uses_and_needs
include index

read -rd '' USAGE <<'EOF'
    phpns - Resolve namespaces and fix missing use statements in your PHP scripts.
    
    USAGE:
        phpns COMMAND [ ARGUMENTS ] [ OPTIONS ]
    
    COMMANDS:
        ns, namespace FILE : resolve the namespace of a file.
        i, index : Index all php files in a project directory for usage.
        fu, find-use CLASS_NAME : Find the use statement needed to import the provided class.
        fxu, fix-uses FILE : Find all used classes that have no use statement in the provided file and add use statements for them.
        cns, classes-in-namespace NAMESPACE: List all classes for a certain namespace
        cmp, complete WORD: Complete FQN's for namespaces and classes that match WORD.
        fp, filepath FQN: print the filepath of a class by the name of FQN.

    TO BE IMPLEMENTED:
        rmuu, remove-unneeded-uses FILE: Remove all use statements for classes that are not being used.

    OPTIONS FOR ALL COMMANDS:
        -s --silent: Don't print info.
    
    UNIQUE OPTIONS PER COMMAND:
        namespace: -
        index:
            -d, --diff: Remove deleted files from index and index new files.
        find-use:
            -j, --json: Provide possible use FQN's as a json array.
            -p, --prefer-own: If there are matches inside the "src" dir, only use those.
            -a, --auto-pick: Use first encountered match, don't provide a choice.
            -b. --bare: Print FQN's without any additives.
        fix-uses:
            -j, --json: Provide possible use FQN's per class as a json object with the class names as keys.
            -p, --prefer-own: If there are matches inside the "src" dir, only use those.
            -a, --auto-pick: Use first encountered match, for every class, don't provide a choice.
            -o, --stdout: Print to stdout in stead of printing to the selected file.
        complete:
            -e, --expand-classes: If WORD is a class name and no namespaces match, provide the FQN for the class that matches WORD.
            -n, --no-classes: Only complete FQN's for namespaces.
            -c, --complete-classes: If no namespaces match and WORD is not a class name, provide FQN's for all partially matching classes.
        filepath:
            -V, --no-vendor: Exclude vendor dir from search.

EOF

execute() {
    declare command="$1" INFO="$INFO"
    declare -a CONFIG=()
    shift

    if [[ $command == @(-h|--help|help) ]]; then
        echo "$USAGE" >&2
        exit 0
    fi

    if ! [[ -f ./composer.json ]] && ! [[ -d ./.git ]]; then
        echo "No composer.json or .git file found, not in root of poject, exiting." >&2
        exit 1
    fi

    case "$command" in
        ns | namespace)
            checkCache
            declare file="$1" cached_file="$TREE_DIR/$1"

            if [[ -f "$cached_file" ]]; then
                grep 'namespace' "$cached_file" | sed 's/namespace\s*//; s/;$//;'
            elif [[ -f "$file" ]]; then
                grep 'namespace' "$file" | sed 's/namespace\s*//; s/;$//;'
            fi
            ;;
        i | index)
            handleArguments index "$@" || return $?
            [[ -d $TREE_DIR ]] || mkdir -p "$TREE_DIR"

            # The arguments to grep need to be dynamic here, because the diff option
            # requires different arguments to be passed to grep.
            declare -a grep_args=(
                -H
                '^\(class\|abstract class\|final class\|namespace\|interface\|trait\) [A-Za-z]\+'
                --exclude-dir={.cache,var}
            )

            # To exclusively index new files, add the filenames to the arguments array
            if [[ ${CONFIG[$INDEX_DIFF]} == '--diff' ]]; then
                declare -a files=()
                files=($(diffIndex))
                if [[ ${#files[@]} -eq 0 ]]; then
                    info '0 new files indexed.'
                    return 0
                fi
                grep_args=("${grep_args[@]}" "${files[@]}")
            else
                rm -rf "${TREE_DIR:?}"/*
                grep_args=("${grep_args[@]}" '-r' '--include=*.php')
            fi

            {
                # Index matching files
                grep -m 2 "${grep_args[@]}"

                # Index non matching files to indicate that they have been parsed.
                # This is necessary for the diff option to work
                grep -lv "${grep_args[@]}" | while read -r line; do echo "$line:NO_NAMESPACE"; done
            } | fillIndex
            ;;
        fu | find-use)
            checkCache
            handleArguments find-use "$@" || return $?
            declare use_path='' class_name="${CONFIG[$CLASS_NAME]}"
            if [[ "$class_name" == @(array|string|float|int|void|mixed) ]]; then
                infof 'Type "%s" is not a class, but a primitive type.\n' "$class_name"
                return 1
            fi

            findUsePathForClass "$class_name"
            ;;
        fxu | fix-uses)
            checkCache
            handleArguments fix-uses "$@" || return $?
            declare file="$1"
            if [[ ${CONFIG[$STDOUT]} == '--stdout' ]]; then
                fixMissingUseStatements "$file"
            else
                # shellcheck disable=SC2005
                echo "$(fixMissingUseStatements "$file")" > "$file"
            fi
            ;;
        cns | classes-in-namespace)
            handleArguments classes-in-namespace "$@" || return $?
            checkCache
            debug "Checking for namespace ${CONFIG[$NAMESPACE]}"
            declare namespace="${CONFIG[$NAMESPACE]}"
            # shellcheck disable=SC2155
            declare matching_files="$(grep -r 'namespace[[:blank:]]\+'"${namespace//\\/\\\\}"'[[:blank:]]*;' --files-with-matches -m 1 "$TREE_DIR")"
            debug "Matching files: $matching_files"
            declare dir="${matching_files%%/+([^/]).php*}"
            debug "Searching dir: $dir"
            [[ -z $dir ]] && return 1
            grep -hPod skip '(?<=class|abstract class|final class|interface|trait)[[:blank:]]+[A-Za-z]+' "$dir"/* \
                | sed 's/^[[:blank:]]\+//g'
            ;;
        cmp | complete)
            handleArguments complete "$@" || return $?
            checkCache
            declare match='false' word="${CONFIG[$WORD]}"

            # First look for matching namespaces
            if grep -oP "^${word//\\/\\\\}"'(\\[A-Za-z_]+|[A-Za-z_]+)?' "$NAMESPACES" \
                | sort -u; then
                match='true'
            fi

            if ! [[ ${CONFIG[$NO_CLASSES]} == '--no-classes' ]]; then
                declare cur_namespace="${word%\\*([^\\])}" 
                debugf 'checking namespace "%s"' "$cur_namespace"
                if compgen -P "$cur_namespace\\" -W "$(execute cns "$cur_namespace")" "${word##*\\}"; then
                    match='true'
                fi
            fi

            if ! $match && [[ ${CONFIG[$EXPAND_CLASSES]} == '--expand-classes' ]] && [[ $word == +([A-Za-z]) ]]; then
                declare -a possibilities=()
                possibilities=($(execute fu --prefer-own --silent --bare "$word"))

                if [[ ${#possibilities[@]} -eq 0 ]] && [[ ${CONFIG[$COMPLETE_CLASSES]} == '--complete-classes' ]]; then
                    declare -a classes=()
                    classes=($(grep "^${word}" "$CLASSES"))
                    for class in "${classes[@]}"; do
                        execute fu --prefer-own --silent --bare "$class"
                    done

                    [[ ${#classes[@]} -gt 1 ]] && echo "$word"
                    return 0
                fi

                printf '%s\n' "${possibilities[@]}"
                [[ ${#possibilities[@]} -gt 1 ]] && echo "$word"
            fi
            ;;
        fp | filepath)
            handleArguments filepath "$@" || return $?
            checkCache
            declare full_use_path="${CONFIG[$CLASS_PATH]}"
            declare namespace="${full_use_path%\\*}"
            declare class="${full_use_path##*\\}"
            debugf 'namespace: "%s" class: "%s"\n' "$namespace" "$class"

            declare -a grep_args=(
                -rPzl 
                "${namespace//\\/\\\\}"';\n(class|abstract class|final class|interface) '"$class"'(\s+|$)'
            )

            if [[ ${CONFIG[$NO_VENDOR]} == '--no-vendor' ]]; then
                grep_args=("${grep_args[@]}" --exclude-dir=vendor)
            fi

            (cd "$TREE_DIR" && grep "${grep_args[@]}")
            ;;
        *)
            printf 'Command "%s" is not a valid phpns command.\n' "$command" >&2
            exit 1
            ;;
    esac
}

# shellcheck disable=SC2034
fixMissingUseStatements() {
    declare check_uses='false' check_needs='false' file="$1"
    declare -A uses=() needs=() namespace=()
    declare -a classes=()
    
    classes=($(execute cns "$(execute ns "$file")"))
    for class in "${classes[@]}"; do
        namespace["$class"]='in_namespace'
    done

    findUsesAndNeeds < "$file"
    addUseStatements "${!needs[@]}" < "$file"
}

findUsePathForClass() {
    declare class="$1"
    if [[ ${CONFIG[$PREFER_OWN]} == '--prefer-own' ]]; then
        declare -a files=($(grep -rl '\(class\|final class\|abstract class\|interface\|trait\)'"\\s\\+${CONFIG[$CLASS_NAME]}\(\\s\\+\|$\)" "$TREE_DIR/src"))
    else
        declare -a files=($(grep -rl '\(class\|abstract class\|final class\|interface\|trait\)'"\\s\\+${CONFIG[$CLASS_NAME]}\(\\s\\+\|$\)" "$TREE_DIR"))
    fi
    declare -a presentable_files=($(for f in "${files[@]}"; do echo "${f#$TREE_DIR/}"; done))

    if [[ ${#presentable_files[@]} -eq 1 ]]; then
        use_path="$(getUsePath "${presentable_files[0]}" "$class_name")"
        debugf 'Single use path "%s" found' "$class_name"
    elif [[ ${#presentable_files[@]} -eq 0 ]]; then
        _handle_no_use
        return $?
    else
        _handle_multiple_uses
    fi

    infof 'Found use statement for "%s"\n' "$use_path" >&2
    if [[ ${CONFIG[$JSON]} == '--json' ]]; then
        echo '['
        echo "$use_path"
        printf ']'
    elif [[ ${CONFIG[$BARE]} ]]; then
        echo "$use_path"
    else
        echo "use $use_path;"
    fi
}

_handle_no_use() {
    if [[ ${CONFIG[$PREFER_OWN]} == '--prefer-own' ]]; then
        CONFIG[$PREFER_OWN]=
        execute fu "${CONFIG[@]}"
        return $?
    else
        infof 'No match found for class "%s"\n' "$class_name" >&2
        [[ ${CONFIG[$JSON]} == '--json' ]] && printf '[]'
    fi
    return 1
}

_handle_multiple_uses() {
    if [[ ${CONFIG[$AUTO_PICK]} == '--auto-pick' ]]; then
        use_path="$(getUsePath "${files[0]}" "$class_name")"

        return 0
    elif [[ ${CONFIG[$BARE]} == '--bare' ]]; then
        debug "Finding uses in  ${#files[@]} files:"
        debugf '    - "%s"\n' "${files[@]}"
        use_path="$(
        for i in "${!files[@]}"; do
            getUsePath "${files[$i]}" "$class_name"
        done 
        )"

        return 0
    elif [[ ${CONFIG[$JSON]} == '--json' ]]; then
        use_path="$(
        for i in "${!files[@]}"; do
            getUsePath "${files[$i]}" "$class_name"
            echo -n "$use_path"
            [[ $i -lt $((${#files[@]}-1)) ]] && printf ','
            echo
        done 
        )"
        
        return 0
    fi

    for i in "${!presentable_files[@]}"; do
        presentable_files[$i]="${presentable_files[$i]} - $(execute ns "${presentable_files[$i]}")\\$class_name"
    done

    infof 'Multiple matches for class "%s", please pick one file.\n' "$class_name" >&2
    select file in "${presentable_files[@]}"; do
        use_path="${file##*- }"
        break
    done < /dev/tty
}

addUseStatements() {
    declare -a needs=("$@")
    declare use_statements=''
    if [[ ${CONFIG[$JSON]} == '--json' ]]; then
        declare -i length="$((${#needs[@]}-1))" current=0
        echo '{'
        for needed in "${needs[@]}"; do
            printf '"%s": ' "$needed"
            execute fu --json "$needed" "${CONFIG[$PREFER_OWN]}" "${CONFIG[$AUTO_PICK]}"
            [[ $((current++)) -lt $length ]] && printf ','
            echo
        done
        echo '}'

        return 0
    fi

    while IFS='' read -r line; do
        echo "$line"

        if [[ $line == namespace* ]]; then
            IFS='' read -r line && echo "$line"

            use_statements="$(
            for needed in "${needs[@]}"; do
                execute fu "$needed" "${CONFIG[$PREFER_OWN]}" "${CONFIG[$AUTO_PICK]}"
            done | sort
            )"

            [[ -n $use_statements ]] && echo "$use_statements"
        fi
    done

    declare -i added_uses=0
    added_uses="$(echo -n "$use_statements" | wc -l)"
    [[ -n $use_statements ]] && ((added_uses++))
    info "$added_uses use statements added out of ${#needs[@]} needed types. Types that were needed:" >&2
    infof '           - "%s"\n' "${needs[@]}" >&2
}

# shellcheck disable=SC2155
getUsePath() {
    declare file="$1" class_name="$2"
    declare use_path="$(execute ns "$file")\\$class_name"
    if [[ ${CONFIG[$JSON]} == '--json' ]]; then
        printf '"%s"' "${use_path//\\/\\\\}"
    else
        echo "$use_path"
    fi
}

execute "$@"
